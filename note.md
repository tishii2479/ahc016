# 全体を通して

- 方針は固めすぎない
    - 実装しすぎない
    - 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
    - ボトムアップに考える
    - 問題の観察を丁寧にする

# 11/11

「次数列の復元 + グラフ構造を使ったヒューリスティック」がテーマっぽい

- 次数列の復元
    - 次数列の距離
- グラフ構造を使ったヒューリスティック
    - 連結成分の個数
    - 二部グラフ
    - ウニ
- M, epsが大きいときはNを大きめにする必要がありそう
- ある程度グラフを作ったら辺の接続を入れ替える焼きなまし?
- グラフ同士の距離が遠くなるように
- クエリのグラフからシミュレーションして、一番確率が高いグラフを出力

- M、epsごとに埋め込みができる
    - グラフの情報は整数で埋め込みできる

- 次数列の距離
    - 次数列をソートした時の各要素の差の二乗和
        ```
        d(0122, 0013) = 0 + 1 + 1 + 1 = 3
        ```
- 次数列からグラフ構築
    - Havel-Hakimi
        - `O(N^2 log N)`
    - 普通にグラフから次数列を作るで良い
        - ソートで`O(N log N)`

- 復元方法
    - シミュレーションした結果、次数列の距離が最小なものを探す
        - epsが大きい時に厳しそう
    - シミュレーションし直すのか、二乗和を考えるだけ?
        - 実行時間5秒あるし、何かしらしそう

- 事前分布をなるべく離す
    - 辺の総数をなるべく離す
        - 等間隔でいいのか、次数列の分布を考えると不均一かも
    - 二項分布
        - `M = N * (N - 1) / 2`
        - `S = 元の辺の総数`
        - `T = 操作後の辺の総数`
        ```
        E(T | S, eps)
            = S * (1 - eps) + (M - S) * eps
            = S + (M - 2 * S) * eps
            = S * (1 - 2 * eps) + M * eps

        eps = 0     ->   1 * S
        eps = 0.4   -> 0.2 * S + 0.4 * M
        eps = 0.5   ->           0.5 * M
        ```
        - ランダムウォーク、マルコフ連鎖
        - `TODO:` ちゃんと確率分布`P(T | S, eps)`を考える
            - 周辺化で解けそう
- 次数の分布
    - 離した方がいいのか、一緒の方がいいのか
        - 他のサイズのグラフによる
            - ここが焼けそうな気がする
            - でも埋め込めるんだよな
        ```
        a = 4 1 1 1 1 0 0 0
        b = 2 2 2 2 0 0 0 0
        c = 7 1 1 1 1 1 1 1
        d = 2 2 2 2 2 2 2 0

        e = 2 2 2 2 2 0 0 0

        s(a) = s(b) = 8
        s(c) = s(d) = 14
        s(e) = 10

        d(a, e) = 8
        d(d, e) = 8
        ```
        - `TODO:` 本質は何か
- サイズ以外でグラフの距離を決めるのは
    - 次数の分布
        - `TODO:` 実験して確かめる
    - 辺の接続の仕方は関係あるか
        - 関係ありそう
            - 辺の接続が切り替わった時の次数列の変化がグラフによって変わるため
        - 関係あるなら、辺の接続は隣接行列で持つ必要がある
- 高速化
    - あらかじめ作ったmaskでxorをとる

# 11/12

