# 全体を通して

- 方針は固めすぎない
    - 実装しすぎない
    - 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
    - ボトムアップに考える
    - 問題の観察を丁寧にする
- 貪欲の質を上げる

# 11/11

「次数列の復元 + グラフ構造を使ったヒューリスティック」がテーマっぽい

- 次数列の復元
    - 次数列の距離
- グラフ構造を使ったヒューリスティック
    - 連結成分の個数
    - 二部グラフ
    - ウニ
- M, epsが大きいときはNを大きめにする必要がありそう
- ある程度グラフを作ったら辺の接続を入れ替える焼きなまし?
- グラフ同士の距離が遠くなるように
- クエリのグラフからシミュレーションして、一番確率が高いグラフを出力

- M、epsごとに埋め込みができる
    - グラフの情報は整数で埋め込みできる

- 次数列の距離
    - 次数列をソートした時の各要素の差の二乗和
        ```
        d(0122, 0013) = 0 + 1 + 1 + 1 = 3
        ```
    - 必要な操作の最小か平均回数
- 次数列からグラフ構築
    - Havel-Hakimi
        - `O(N^2 log N)`
    - 普通にグラフから次数列を作るで良い
        - ソートで`O(N log N)`

- 復元方法
    - シミュレーションした結果、次数列の距離が最小なものを探す
        - epsが大きい時に厳しそう
    - シミュレーションし直すのか、二乗和を考えるだけ?
        - 実行時間5秒あるし、何かしらしそう
        - 必要な操作の最小か平均回数を求める

- 事前分布をなるべく離す
    - 辺の総数をなるべく離す
        - 等間隔でいいのか、次数列の分布を考えると不均一かも
    - 二項分布
        - `M = N * (N - 1) / 2`
        - `S = 元の辺の総数`
        - `T = 操作後の辺の総数`
        ```
        E(T | S, eps)
            = S * (1 - eps) + (M - S) * eps
            = S + (M - 2 * S) * eps
            = S * (1 - 2 * eps) + M * eps

        eps = 0     ->   1 * S
        eps = 0.4   -> 0.2 * S + 0.4 * M
        eps = 0.5   ->           0.5 * M
        ```
        - ランダムウォーク、マルコフ連鎖
        - `TODO:` ちゃんと確率分布`P(T | S, eps)`を考える
            - 周辺化で解けそう
- 次数の分布
    - 離した方がいいのか、一緒の方がいいのか
        - 他のサイズのグラフによる
            - ここが焼けそうな気がする
            - でも埋め込めるんだよな
        ```
        a = 4 1 1 1 1 0 0 0
        b = 2 2 2 2 0 0 0 0
        c = 7 1 1 1 1 1 1 1
        d = 2 2 2 2 2 2 2 0

        e = 2 2 2 2 2 0 0 0
        f = 5 1 1 1 1 1 0 0

        s(a) = s(b) = 8
        s(c) = s(d) = 14
        s(e) = 10

        d(a, e) = 8
        d(d, e) = 8
        ```
        - `TODO:` 本質は何か
- サイズ以外でグラフの距離を決めるのは
    - 次数の分布
        - `TODO:` 実験して確かめる
    - 辺の接続の仕方は関係あるか
        - 同じ次数列でも違うグラフがある
        - 関係ありそう
            - 辺の接続が切り替わった時の次数列の変化がグラフによって変わるため
        - 関係あるなら、辺の接続は隣接行列で持つ必要がある
- 高速化
    - あらかじめ作ったmaskでxorをとる

# 11/12

- 橋の数は使えそう
    - 削除と追加が同じ確率で行われるので、そこまでかも
- グラフの距離は必要な操作の最小か平均回数
    - 頂点番号がないので、厳密に求めるのは難しい

## 方針

### 1. なるべく離れた位置にあるグラフを構築する

1. M個のグラフをランダムに初期化する
2. 隣接するグラフの距離が遠くなるように焼く
    - 辺の接続を入れ替える
    - 辺の接続先を変更する
3. 構築したグラフを出力する

### 2. クエリを受け取って復元する　

1. グラフを受け取る
2. 受け取ったグラフと構築したグラフの距離を求め、最も近いグラフを出力する

### 必要な要素

- グラフの距離の正確な定義
    - グラフの類似度を測る手法
    - 辺の削除、追加の必要回数
        - グラフ編集距離（Graph Edit Distance）の辺だけ
    - グラフの編集距離を求める問題はNP-Hard
        - 頂点をどう対応させるか（ノードマッピング）をA*アルゴリズムを使って最適化するとある程度のサイズまで解けるらしい
            - https://proceedings-of-deim.github.io/DEIM2022/papers/I44-1.pdf

- 頂点番号の対応付けを行うと、編集距離は計算できる
    - 対応付けを最適化して、編集距離を最小にした時の値を使う
        - 焼きなまし
            - 2頂点をswap
            - 遅い
        - ビームサーチ
            - 構築するときはこっち?
            - 早い
        - ある程度の貪欲

- M個のグラフの構築は工夫が必要
    - 全体の距離を考慮した評価関数を考える必要がある
- 復元するときには辺の追加、削除は考える必要がある

## 今後の方針

1. 構築
2. 復元

- 復元
    - Mが大きくても、最初に辺の総数によってある程度絞り込める
    - 難しい問題ほど時間を多く取る

## 11/13

類似度をより正確に、高速に求める

- ビームサーチで初期解を作る
- 編集距離の近似手法が必要かも

- グラフ生成の評価関数をminではなく総和に
    - 近い値を重視するために、距離の0.5乗を使う

- 辺の総数の平均の変化を考慮する必要がある
    - 特にepsが大きいとき
        -　辺の総数は `N * (N - 1) / 2` に近づく
    - グラフの単純な類似度だけだと、epsが大きい時に駄目

- epsが大きい時の対策を考える
    - 何回かシミュレーションして、その後類似度を求める
        - 相当良い
- m, epsが小さいときは強い

```
N = 30
ave: 6509895.81
err ave: 46.21
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |  44859999   26919002    8708427    3506621    6348444    1549501      24174      74430
   40~70 |  16277643    7419666    2225835     336712      63930      22186       8730       6471
  70~100 |  12251409    1337414     364372     130049      12719       6437       2570       2233
```

- 埋め込みはNの値だけしか無理そう
    - ファイルサイズは 512 KiB
    - 構築は後でやる必要がありそう
- 構築と復元の時間管理が必要
- Nの調整は結構大変

### 改善点

- epsが大きい時をもう少しまともに考える
- グラフの構築
    - 次数列の分布を考慮する
- グラフの類似度の求め方
    - 次数列の分布の類似度

```
初期値 - 前から埋める
N = 30
ave: 6898415.96
err ave: 47.22
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |  45999999   31166666   16001577    4316389   10605972    1618038      22847      42544
   40~70 |  16519474   10266694    1137285     296730      31872      18525       6157       4633
  70~100 |  12976136     806712     242721      41903      11551       2924       2262       2179

N = 60
ave: 9145799.02
err ave: 31.42
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |  36000000   20000000   20000000   15755971   16561000    7686412     216537     292992
   40~70 |  22375912   17731633    8967922    2683729     350564     141418      11285      10418
  70~100 |  19750000    7933869    3277132     724819      98813      12110       4785       1821

N = 100
ave: 7829406.87
err ave: 14.56
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |  28000000   10000000   10000000   10000000   10000000    8198102    3194002    2827766
   40~70 |  14375912   10000000   10000000    9600000    5671984    2571413     438233     111269
  70~100 |  10000000   10000000    9857142    8498000    3336008     442661      94742       4752

N = rulebase (if eps == 0. { 10 } else if eps <= 0.10 { 60 } else if m <= 40 && eps <= 0.30 { 60 } else { 100 })
ave: 10018985.5
err ave: 15.51
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |  33333333   16666667   16666667   15285714   15083333    8590760    2531923    2929059
   40~70 |  19709246   16111111   11666666    9600000    5671984    2590149     407151     110636
  70~100 |  16666667   10086484    9310636    8460000    3815607     530806      69264       4497

error table:
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |      0.00       0.00       0.00       1.00       1.00      12.50      16.60      21.14
   40~70 |      3.40       0.33       0.33       0.40       4.50      15.60      35.67      48.00
  70~100 |      0.00       4.67       1.29       1.80      10.67      36.00      49.33      78.14
```

### 現状の解法の整理

1. グラフの構築
    1. i番目に構築するグラフの辺の総数を`N * (N - 1) / 2 / (M - 1) * i`として、順番に頂点に辺を足す
2. グラフの復元
    1. 構築したグラフをモンテカルロでシミュレーションして、受け取ったグラフとの類似度を求める
        - 辺の総数が違いすぎるグラフはあらかじめ弾いている

### 改善点

- シミュレーションした後のGを保持して使い回す
- 類似度の求め方
    - やはりグラフの構造を使いたい
- 他の復元方法の模索

### テーマ

ノイズに強いグラフとは
