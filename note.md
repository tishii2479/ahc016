# 全体を通して

- 方針は固めすぎない
    - 実装しすぎない
    - 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
    - ボトムアップに考える
    - 問題の観察を丁寧にする
- 貪欲の質を上げる

# 11/11

「次数列の復元 + グラフ構造を使ったヒューリスティック」がテーマっぽい

- 次数列の復元
    - 次数列の距離
- グラフ構造を使ったヒューリスティック
    - 連結成分の個数
    - 二部グラフ
    - ウニ
- M, epsが大きいときはNを大きめにする必要がありそう
- ある程度グラフを作ったら辺の接続を入れ替える焼きなまし?
- グラフ同士の距離が遠くなるように
- クエリのグラフからシミュレーションして、一番確率が高いグラフを出力

- M、epsごとに埋め込みができる
    - グラフの情報は整数で埋め込みできる

- 次数列の距離
    - 次数列をソートした時の各要素の差の二乗和
        ```
        d(0122, 0013) = 0 + 1 + 1 + 1 = 3
        ```
    - 必要な操作の最小か平均回数
- 次数列からグラフ構築
    - Havel-Hakimi
        - `O(N^2 log N)`
    - 普通にグラフから次数列を作るで良い
        - ソートで`O(N log N)`

- 復元方法
    - シミュレーションした結果、次数列の距離が最小なものを探す
        - epsが大きい時に厳しそう
    - シミュレーションし直すのか、二乗和を考えるだけ?
        - 実行時間5秒あるし、何かしらしそう
        - 必要な操作の最小か平均回数を求める

- 事前分布をなるべく離す
    - 辺の総数をなるべく離す
        - 等間隔でいいのか、次数列の分布を考えると不均一かも
    - 二項分布
        - `M = N * (N - 1) / 2`
        - `S = 元の辺の総数`
        - `T = 操作後の辺の総数`
        ```
        E(T | S, eps)
            = S * (1 - eps) + (M - S) * eps
            = S + (M - 2 * S) * eps
            = S * (1 - 2 * eps) + M * eps

        eps = 0     ->   1 * S
        eps = 0.4   -> 0.2 * S + 0.4 * M
        eps = 0.5   ->           0.5 * M
        ```
        - ランダムウォーク、マルコフ連鎖
        - `TODO:` ちゃんと確率分布`P(T | S, eps)`を考える
            - 周辺化で解けそう
- 次数の分布
    - 離した方がいいのか、一緒の方がいいのか
        - 他のサイズのグラフによる
            - ここが焼けそうな気がする
            - でも埋め込めるんだよな
        ```
        a = 4 1 1 1 1 0 0 0
        b = 2 2 2 2 0 0 0 0
        c = 7 1 1 1 1 1 1 1
        d = 2 2 2 2 2 2 2 0

        e = 2 2 2 2 2 0 0 0
        f = 5 1 1 1 1 1 0 0

        s(a) = s(b) = 8
        s(c) = s(d) = 14
        s(e) = 10

        d(a, e) = 8
        d(d, e) = 8
        ```
        - `TODO:` 本質は何か
- サイズ以外でグラフの距離を決めるのは
    - 次数の分布
        - `TODO:` 実験して確かめる
    - 辺の接続の仕方は関係あるか
        - 同じ次数列でも違うグラフがある
        - 関係ありそう
            - 辺の接続が切り替わった時の次数列の変化がグラフによって変わるため
        - 関係あるなら、辺の接続は隣接行列で持つ必要がある
- 高速化
    - あらかじめ作ったmaskでxorをとる

# 11/12

- 橋の数は使えそう
    - 削除と追加が同じ確率で行われるので、そこまでかも
- グラフの距離は必要な操作の最小か平均回数
    - 頂点番号がないので、厳密に求めるのは難しい

## 方針

### 1. なるべく離れた位置にあるグラフを構築する

1. M個のグラフをランダムに初期化する
2. 隣接するグラフの距離が遠くなるように焼く
    - 辺の接続を入れ替える
    - 辺の接続先を変更する
3. 構築したグラフを出力する

### 2. クエリを受け取って復元する　

1. グラフを受け取る
2. 受け取ったグラフと構築したグラフの距離を求め、最も近いグラフを出力する

### 必要な要素

- グラフの距離の正確な定義
    - グラフの類似度を測る手法
    - 辺の削除、追加の必要回数
        - グラフ編集距離（Graph Edit Distance）の辺だけ
    - グラフの編集距離を求める問題はNP-Hard
        - 頂点をどう対応させるか（ノードマッピング）をA*アルゴリズムを使って最適化するとある程度のサイズまで解けるらしい
            - https://proceedings-of-deim.github.io/DEIM2022/papers/I44-1.pdf

- 頂点番号の対応付けを行うと、編集距離は計算できる
    - 対応付けを最適化して、編集距離を最小にした時の値を使う
        - 焼きなまし
            - 2頂点をswap
            - 遅い
        - ビームサーチ
            - 構築するときはこっち?
            - 早い
        - ある程度の貪欲

- M個のグラフの構築は工夫が必要
    - 全体の距離を考慮した評価関数を考える必要がある
- 復元するときには辺の追加、削除は考える必要がある

## 今後の方針

1. 構築
2. 復元

- 復元
    - Mが大きくても、最初に辺の総数によってある程度絞り込める
    - 難しい問題ほど時間を多く取る

## 11/13

類似度をより正確に、高速に求める

- ビームサーチで初期解を作る
- 編集距離の近似手法が必要かも

- グラフ生成の評価関数をminではなく総和に
    - 近い値を重視するために、距離の0.5乗を使う

- 辺の総数の平均の変化を考慮する必要がある
    - 特にepsが大きいとき
        -　辺の総数は `N * (N - 1) / 2` に近づく
    - グラフの単純な類似度だけだと、epsが大きい時に駄目

- epsが大きい時の対策を考える
    - 何回かシミュレーションして、その後類似度を求める
        - 相当良い
- m, epsが小さいときは強い

```
ave: 6509895.81
err ave: 46.21
         |    0~0.05   0.05~0.1   0.1~0.15   0.15~0.2   0.2~0.25   0.25~0.3   0.3~0.35   0.35~0.4
-------------------------------------------------------------------------------------------------
   10~40 |  44859999   26919002    8708427    3506621    6348444    1549501      24174      74430
   40~70 |  16277643    7419666    2225835     336712      63930      22186       8730       6471
  70~100 |  12251409    1337414     364372     130049      12719       6437       2570       2233
```

- 埋め込みはNの値だけしか無理そう
    - ファイルサイズは 512 KiB
    - 構築は後でやる必要がありそう
- 構築と復元の時間管理が必要

### TODO: 現状の解法の整理

- 次数列だけで類似度を求めている
    - もう少し正確に類似度を求めたい
